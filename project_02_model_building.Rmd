---
title: "project_02_models"
author: "Ryan Folks"
date: "8/11/2021"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
library(MASS)
library(tidyverse)
library(gridExtra)
library(corrplot)
library(ROCR)
```

```{r}
white_wine <- read.csv('wineQualityWhites.csv')
red_wine <- read.csv('wineQualityReds.csv')

white_wine <- dplyr::select(white_wine, -c(free.sulfur.dioxide, X))
red_wine <- dplyr::select(red_wine, -c(free.sulfur.dioxide, X))

red_wine <- red_wine %>%
  mutate(color = 0) #red is 0
white_wine <- white_wine %>%
  mutate(color = 1) #white is 1

#add quality_cat
red_wine <- red_wine %>%
  mutate(quality_cat = ifelse(quality>=7, 1, 0)) #high quality 1, low quality 0
white_wine <- white_wine %>%
  mutate(quality_cat = ifelse(quality>=7, 1, 0)) #high quality 1, low quality 0

#change color to factor
red_wine$color<-factor(red_wine$color)
levels(red_wine$color) <- c('red') 
white_wine$color<-factor(white_wine$color)
levels(white_wine$color) <- c('white')

#change quality_cat to factor 
red_wine$quality_cat<-factor(red_wine$quality_cat)
levels(red_wine$quality_cat) <- c("low","high") 
white_wine$quality_cat<-factor(white_wine$quality_cat)
levels(white_wine$quality_cat) <- c("low","high") 

wine_combined <- rbind(white_wine, red_wine) #combine datasets 

#split into train and test data
set.seed(1) #set seed 
#white
sample_white<-sample.int(nrow(white_wine), floor(.80*nrow(white_wine)), replace = F)
train_white<-white_wine[sample_white, ] #training data 
test_white<-white_wine[-sample_white, ] #testing data

#red
sample_red<-sample.int(nrow(red_wine), floor(.80*nrow(red_wine)), replace = F)
train_red<-red_wine[sample_red, ] #training data 
test_red<-red_wine[-sample_red, ] 

#combined
train_combined <- rbind(train_white, train_red)
test_combined <- rbind(test_white, test_red) 
```


# Model Building

## Red Wine Model
```{r}
train_red <- train_red %>% dplyr::select(-c(color, quality))
train_white <- train_white %>% dplyr::select(-c(color, quality))
```

Our initial Exploratory Data Analysis suggests that we should build two separate models to classify the quality of red and white wines as "low" or "high". We decided to employ the all possible regressions procedure to determine which of the ten predictors may be considered the most important in predicting the quality category of red wine. All-possible-regressions is an automated procedure that goes beyond stepwise regression and tests all possible subsets of the set of potential independent variables, which in the context of our problem is 2^10 = 1024 possible subsets. We set the default value for nbest to 1, which tells the algorithm to return the one best set of predictors (based on R2) for each number of possible predictors. We also set nvmax to 10 so all possible subsets are displayed.

```{r}
allreg_red <- regsubsets(quality_cat ~., data=train_red, nbest=1, nvmax=10)
summary(allreg_red)
#R2
which.max(summary(allreg_red)$adjr2)
#model 9 is the best based on R2
#CP
which.min(summary(allreg_red)$cp)
#model 8 is the best based on Mallow's CP
#BIC
which.min(summary(allreg_red)$bic)
#model 7 based on BIC
```

After running the algorithm, we extract the best models based on the following criteria: R2, Mallow's Cp and BIC. For allreg_red, model 9 has the best adjusted R2, model 8 has the best Mallow's Cp and model 7 has the best BIC. In our case, the model number corresponds to the number of predictors being used. Based on these results, we select the proposed 7-predictor model for our initial model building process. The 7-predictor model uses the following predictor variables to classify the quality of red wine as "low" or "high": alcohol, volatile.acidity, sulphates, fixed.acidity, density, residual.sugar and chlorides.

```{r}
#all possible regression model, based on BIC -> 7-predictor model
model1_red <- glm(quality_cat~ alcohol+volatile.acidity+sulphates+fixed.acidity+density+residual.sugar+chlorides, 
                  family='binomial', data=train_red)
summary(model1_red) #AIC score 738.12
```
The fitted 7-predictor logistic regression equation for red wine is displayed as follows:

log(pi(quality)/1+pi(quality)) =(285.10221 + (0.72351)alcohol + (-2.82651)volatile.acidity + (3.23950)sulphates +  (0.36775)fixed.acidity + (-299.78128)density + (0.17416)residual.sugar + (-7.54886)chlorides  

The Z test associated with all the coefficients are considered statistically significant at the .05 level, which suggests that all 7 predictor variables should be kept in our model. 

The next step in our procedure is to check that our proposed model meets all the assumptions for logistic regressions, which are defined as follows:

1) There is a linear relationship between the logit of the outcome and each predictor variables. 
2) There are no influential values (extreme values or outliers) in the continuous predictors
3) There are no high intercorrelations (i.e. multicollinearity) among the predictors.

To determine that the first assumption has been met, we check the linear relationship between continuous predictor variables and the logit of the outcome. This is done by visually inspecting the scatter plot between each predictor variable and the logit values. 
```{r}
probabilities <- predict(model1_red, type = "response")
predicted.classes <- ifelse(probabilities > 0.5, "pos", "neg")
head(predicted.classes)

model_red <- train_red%>%
  dplyr::select(is.numeric) 
predictors <- colnames(model_red)
#Bind the logit and tidying the data for plot
model_red <- model_red %>%
  mutate(logit = log(probabilities/(1-probabilities))) %>%
  gather(key = "predictors", value = "predictor.value", -logit)

ggplot(model_red, aes(logit, predictor.value))+
  geom_point(size = 0.5, alpha = 0.5) +
  geom_smooth(method = "loess") + 
  theme_bw() + 
  facet_wrap(~predictors, scales = "free_y")
```
The smoothed scatter plots show that alcohol, sulphates and volatile.acidity are quite linearly associated with the quality_cat outcome in logit scale. The smoother scatter plots for the other predictor variables show little to no linear association with the quality_cat outcome in logit scale, which leads us to believe they are weaker predictors. None of the scatterplots lead us to believe that assumption 1 has been violated, and we therefore move on without transforming variables and begin to explore our next assumption. 

Next, we generate the residuals, studentized residuals and externally studentized residuals associated with our 7-predictor model to help detect any outliers. We combine these residual values into a dataframe and create scatterplots of the studentized and externally studentized residuals in order to visually inspect for the presence of outliers.
```{r}
#ASSUMPTION 2 -> outliers and inluential variables 
#residuals -> used to help detect outliers 
res<-model1_red$residuals
# studentized residuals 
student.res<-rstandard(model1_red)
# externally studentized residuals
ext.student.res<-rstudent(model1_red)

res.frame<-data.frame(res,student.res,ext.student.res)
res.frame

par(mfrow=c(1,2))
plot(model1_red$fitted.values,student.res,
     main="Studentized Residuals",
     ylim=c(-4.5,4.5))
plot(model1_red$fitted.values,ext.student.res,
     main="Externally Studentized Residuals",
     ylim=c(-4.5,4.5))
#plots look very similar, suggests that there are no outliers 
```
The resulting plots look very similar, which leads us to believe there are no outliers in our model. 

Next, we calculate leverages to identify how far each observation is from the center of the predictor space. If the leverage is greater than 2p/n, the associated observation may be deemed to have high leverage and is considered outlying in the predictor space. In this case p, which corresponds to the number of predictor variables in our model, is 7 and n, the number of records in our training set for red wine, is 1279. 
```{r}
#leverage
p <- 7 #7 predictor model
n<-dim(train_red)[1]
lev<-lm.influence(model1_red)$hat 
##identify high leverage points 
lev[lev>2*p/n]
#high leverage observations are data points that are likely to be influential 
```

Due to the number of observations that were found to have high leverage, we decided to calculate Cook's Distance in order to determine if these high leverage observations were influential and were consequently negatively affecting our regression model. We decided to use Cook's distance measure as we are mainly concerned with the predictive ability of our logistic model. A large value indicates that the observation has a large influence on the results. The Cook's Distance of each observation was compared to the a cut off value generated by the following F distribution: F0.5,p,n-p, where p is 7 and n is 1279.

```{r}
#influential 
#cooks distance
COOKS<-cooks.distance(model1_red)
COOKS[COOKS>qf(0.5,p,n-p)]
#no influential points based on COOK's distance

#DONT THINK WE NEED THESE
##dffits
DFFITS<-dffits(model1_red)
DFFITS[abs(DFFITS)>2*sqrt(p/n)]
#shows influential points, but we are concerned with prediction, rely more heavily on cook's distance

#dfbetas
DFBETAS<-dfbetas(model1_red)
abs(DFBETAS)>2/sqrt(n)
#shows influential points, again more concerned with prediction, rely more on cook's distance 
```

None of the generated Cook's distance values exceeded the cutoff value, which leads us to believe that none of our observations in our model are influential. We conclude that assumption 2 has been met, and move on to the final assumption.

Next, we check for multicollinearity in our model. Multicollinearity corresponds to a situation where two or more predictors are linearly dependent on each other. When two or more predictors are linearly dependent, they do not provide independent information to the response, resulting in large standard errors for the coefficients. We can check for multicollinearity by computing the variance inflation factors (VIFs) for each predictor variable. As a rule of thumb, A VIF value that exceeds 5 indicates a problematic amount of collinearity and needs to be explored, whereas a value greater than 10 indicates a serious amount of collinearity and must be immediately addressed. 

```{r}
#ASSUMPTION 3
#mutlicollinearity 
vif(dplyr::select(train_red, c(alcohol,volatile.acidity,sulphates,fixed.acidity,density,residual.sugar,chlorides)))
#VIF score above 10 indicates high correlation, cause for concern, VIF scores less than 10 across the board
#############################################################
```
The resulting VIFs are below 5 for all 7 of the predictor variables in our model, which leads us to conclude that the third assumption has been satisfied. 

After checking that all the model assumptions have been met, we move on to comparing our 7-predictor model with other possible logistic regression models using Likelihood Ratio Tests (LRTs) to evaluate if our proposed model is useful in classifying red wine as either "low" or "high" quality (quality_cat). 

First, we compare our 7-predictor model to the intercept only model. 

The null hypothesis is:
Ho:beta(alcohol)=beta(volatile.acidity)=beta3(sulphates)=beta4(fixed.acidity)=beta5(density)=beta6(residual.sugar)=beta7(chlorides)=0 

versus the alternative hypothesis:

Ha:at least one of the coefficients is not zero. 

We calculate the test statistic, which measures the difference in loglikelihoods of the models we are comparing, and compare it with a chi square distribution, where the degrees of freedom equal the number of coefficients we are testing (7). For this comparison, the test statistic is the difference in the null deviance and residual deviance of the 7-predictor model.
```{r}
#TESTING MODEL 7-PRED MODEL
#############################################################
#Test that 7-predictor model is useful
##test if coefficients for all 7 predictors are 0 
#H0: beta1=beta2=beta3=beta4=beta5=beta6=beta7=0
#HA: at least one of the coefficients in HO is not zero
##test stat
TS<-model1_red$null.deviance-model1_red$deviance
TS
#p-value 
1-pchisq(TS,7)
#p-value is 0
#So we reject the null hypothesis. The 7-predictor model is chosen over the intercept-only model;
#the 7-predictor model is useful.
```
The generated test statistic is 291.5332 with an associated p-value of 0. Therefore, we reject the null hypothesis and conclude that our 7-predictor model is useful and should be selected over the intercept-only model.

Next, we decide to compare our 7-predictor model to the full (10-predictor) model. 

The null hypothesis is:
Ho:beta(pH)=beta(citric.acid)=beta(total.sulfur.dioxide)=0

versus the alternative hypothesis: 

Ha:at least one of the coefficients is not zero. 

Again we calculate the test statistic, and compare it with a chi square distribution with 3 degrees of freedom (as we are testing 3 coefficients). For this comparison, the test statistic is the difference in the residual deviances of both models.
```{r}
#test if 7-predictor model more useful then full (10 predictor model)
#H0: beta8=beta9=beta10=0
#HA: at least one of the coefficients in HO is not zero
full_red<-glm(quality_cat ~ ., family = "binomial", data=train_red)

TS2<-model1_red$deviance-full_red$deviance
TS2  #13.3604
#pvalue
1-pchisq(TS2,3) #0.003918644
```
The generated test statistic is 13.3604 with an associated p-value of 0.003918644. Therefore, we fail reject the null hypothesis and conclude that the 7-predictor model is not as useful as the full (10-predictor) model.

We found this result to be interesting, and decided to explore the full model in more depth.

```{r}
summary(full_red)
```
We see that the Z test scores associated with the coefficients for predictors pH and citric.acid are insignificant. The next step is to compute VIFs for each of the 10 predictos in the full model to determine if multicollinearity exists between any of the variables.

```{r}
#check full model multicollinearity 
vif(dplyr::select(train_red, c(alcohol,volatile.acidity,sulphates,fixed.acidity,density,residual.sugar,chlorides, pH,
                               citric.acid, total.sulfur.dioxide)))
#no multicollinearity, pH and citric.acid appear to not be significant predictors (based on 
#wald test scores), can drop, end up with 8-predictor model
```
The resulting VIFs suggests that none of the variables are linearly dependent on one another, and we conclude that pH and citric.acid are not significant predictors for classifying red wine as "low" or "high" an drop them from the full model. We now have two candidate models for classifying the quality of red wine: our original 7-predictor model (model1_red) and the 8-predictor model (model2_red). We decide to test both these models using the test_red dataset in order to determine which is more useful in answering our research question. 

```{r}
#8-predictor model
model2_red <- glm(quality_cat~alcohol+volatile.acidity+sulphates+fixed.acidity+density+residual.sugar+chlorides+
                  total.sulfur.dioxide, family = "binomial", data=train_red)
summary(model2_red)
#####################################################
```

First, we store the predicted probabilities of the test_red data based on our 7-predictor logistic regression model in the variable preds. We then transform this data using the prediction() function and store the values of the true positive rate and false positive rate in the roc_result object. We then use this object to generate a ROC curve for our 7-predictor logistic regression model. The ROC curve plots the true positive rate (TPR) against the false positive rate (FPR) of the model as the threshold value is varied from 0 to 1. The ROC curve generated by our 7-predictor model lies above the diagonal, which indicates the logistic regression does a better job than random guessing when classifying red wines as "low" or "high" quality. We also generate an Area Under the Curve (AUC) associated with this ROC curve. The AUC value for our model is 0.889574, which again provides evidence that our model does better at classifying red wines then random guessing (represented by an AUC score of 0.5). Finally, we produce a confusion matrix, which contains the number of observations in each class ("low" and "high" quality red wine) and the number of predicted observations in each class (for test_red) generated by our 7-predictor model using a threshold value of 0.5. 
```{r}
#ROC/AUC/CONFUSION MATRIX TO COMPARE 7 AND 8-PRED MODELS 
#####################################################
##ROC AND AUC FOR 7-PREDICTOR MODEL##
##predicted survival rate for test data based on training data
preds<-predict(model1_red, newdata=test_red, type="response")
##transform the input data into a format that is suited for the
##performance() function
rates<-prediction(preds, test_red$quality_cat, label.ordering = c("low", "high"))
##store the true positive and false positive rates
roc_result<-performance(rates,measure="tpr", x.measure="fpr")

##plot ROC curve and overlay the diagonal line for random guessing
plot(roc_result, main="ROC Curve for Red Wine Quality Prediction")
lines(x = c(0,1), y = c(0,1), col="red")

auc<-performance(rates, measure = "auc")
auc@y.values #0.8896574, suggests are model classify observations better than random guessing 

table(test_red$quality_cat, preds>0.50)
#####################################################
```

Next, we follow a similar assessment procedure using the test_red dataset and the 8-predictor model.The ROC curve generated by our 8-predictor model lies above the diagonal, which indicates the logistic regression does a better job than random guessing when classifying red wines as "low" or "high" quality.  The AUC value for this model is 0.8978096, which again provides evidence that our 8-predictor model does slightly better at classifying red wines than our 7-predictor model. Finally, we produce a confusion matrix generated by the 8-predictor model using a threshold value of 0.5. 
```{r}
#####################################################
##ROC AND AUC FOR 8-predictor MODEL##
preds_2<-predict(model2_red, newdata=test_red, type="response")
##transform the input data into a format that is suited for the
##performance() function
rates_2<-prediction(preds_2, test_red$quality_cat, label.ordering = c("low", "high"))
##store the true positive and false positive rates
roc_result_2<-performance(rates_2,measure="tpr", x.measure="fpr")

##plot ROC curve and overlay the diagonal line for random guessing
plot(roc_result_2, main="ROC Curve for Red Wine Quality Prediction")
lines(x = c(0,1), y = c(0,1), col="red")

auc_full<-performance(rates_2, measure = "auc")
auc_full@y.values #0.8978096, suggests are model classify observations better than random guessing 

table(test_red$quality_cat, preds_2>0.50)
#####################################################
```
In terms of our research question, we are most interested in maximizing the ratio of the true positive results to the false positive results. The number of false positive results (low quality wines incorrectly categorized as high quality) is 6 and the number of true positive results (high quality wines correctly categorized as high quality) is 15 for our 7-predictor model, whereas the number of false positive results is 9 and the number of true positive results is 15 for our 8-predictor model. The calculated ratio of true positive results to false positive results is larger for our 7-predictor model, so we select it over the 8-predictor model.
























## White Wine Model  


























```{r}
allreg_white <- regsubsets(quality_cat ~., data=train_white, nbest=1, nvmax=10)
summary(allreg_white)
```

```{r}
which.min(summary(allreg_white)$bic)
which.min(summary(allreg_white)$cp)
which.max(summary(allreg_white)$adjr2)
```

```{r}
model1_white <- glm(quality_cat ~ fixed.acidity + volatile.acidity + residual.sugar + density + pH + sulphates + alcohol,
                    family='binomial', data=train_white)
summary(model1_white)
```

Based on the output, we should remove alcohol.  

```{r}
model2_white <- glm(quality_cat ~ fixed.acidity + volatile.acidity + residual.sugar + density + pH + sulphates,
                    family='binomial', data=train_white)
summary(model2_white)
```

```{r}
model3_white <- glm(quality_cat ~ volatile.acidity + residual.sugar + alcohol + pH + sulphates,
                    family='binomial', data=train_white)
summary(model2_white)
```

```{r}
TS<-model2_white$null.deviance-model1_red$deviance
TS
#p-value 
1-pchisq(TS,7)
```

```{r}
full_white<-glm(quality_cat ~ ., family = "binomial", data=train_white)
summary(full_white)

TS2<-model2_white$deviance-full_white$deviance
TS2  #1.502435
#pvalue
1-pchisq(TS2,3)
```

```{r}
##predicted survival rate for test data based on training data
preds<-predict(full_white, newdata=test_white, type="response")
##transform the input data into a format that is suited for the
##performance() function
rates<-prediction(preds, test_white$quality_cat, label.ordering = c("low", "high"))
##store the true positive and false positive rates
roc_result<-performance(rates,measure="tpr", x.measure="fpr")


##plot ROC curve and overlay the diagonal line for random guessing
plot(roc_result, main="ROC Curve for White Wine Quality Prediction")
lines(x = c(0,1), y = c(0,1), col="red")
```

```{r}
table(test_white$quality_cat, preds>0.5)
table(test_white$quality_cat, preds>0.4)
table(test_white$quality_cat, preds>0.36)
table(test_white$quality_cat, preds>0.33)
table(test_white$quality_cat, preds>0.1)
```

```{r}
##predicted survival rate for test data based on training data
preds<-predict(model3_white, newdata=test_white, type="response")
##transform the input data into a format that is suited for the
##performance() function
rates<-prediction(preds, test_white$quality_cat, label.ordering = c("low", "high"))
##store the true positive and false positive rates
roc_result<-performance(rates,measure="tpr", x.measure="fpr")


##plot ROC curve and overlay the diagonal line for random guessing
plot(roc_result, main="ROC Curve for White Wine Quality Prediction")
lines(x = c(0,1), y = c(0,1), col="red")
```

```{r}
table(test_white$quality_cat, preds>0.5)
table(test_white$quality_cat, preds>0.4)
table(test_white$quality_cat, preds>0.36)
table(test_white$quality_cat, preds>0.33)
table(test_white$quality_cat, preds>0.1)
```

```{r}
model4_white <- glm(quality_cat ~ fixed.acidity + volatile.acidity + citric.acid + chlorides + total.sulfur.dioxide + pH + sulphates                                 + alcohol + quality_cat,
                    family='binomial', data=train_white)
summary(model2_white)
```

```{r}
##predicted survival rate for test data based on training data
preds<-predict(model4_white, newdata=test_white, type="response")
##transform the input data into a format that is suited for the
##performance() function
rates<-prediction(preds, test_white$quality_cat, label.ordering = c("low", "high"))
##store the true positive and false positive rates
roc_result<-performance(rates,measure="tpr", x.measure="fpr")


##plot ROC curve and overlay the diagonal line for random guessing
plot(roc_result, main="ROC Curve for White Wine Quality Prediction")
lines(x = c(0,1), y = c(0,1), col="red")
```

```{r}
table(test_white$quality_cat, preds>0.5)
table(test_white$quality_cat, preds>0.4)
table(test_white$quality_cat, preds>0.36)
table(test_white$quality_cat, preds>0.33)
table(test_white$quality_cat, preds>0.1)
```

```{r}
probabilities <- predict(model4_white, type = "response")
predicted.classes <- ifelse(probabilities > 0.5, "pos", "neg")
head(predicted.classes)

#ASSUMPTION 1) Linearity assumption
# Select only numeric predictors
model_white <- train_white%>%
  dplyr::select(is.numeric) 
predictors <- colnames(model_white)
#Bind the logit and tidying the data for plot
model_white <- model_white %>%
  mutate(logit = log(probabilities/(1-probabilities))) %>%
  gather(key = "predictors", value = "predictor.value", -logit)

ggplot(model_white, aes(logit, predictor.value))+
  geom_point(size = 0.5, alpha = 0.5) +
  geom_smooth(method = "loess") + 
  theme_bw() + 
  facet_wrap(~predictors, scales = "free_y")
```


```{r}
res<-model4_white$residuals
#studentized residuals 
student.res<-rstandard(model4_white)
#externally studentized residuals
ext.student.res<-rstudent(model4_white)

res.frame<-data.frame(res,student.res,ext.student.res)
res.frame

par(mfrow=c(1,2))
plot(model4_white$fitted.values,student.res,
     main="Studentized Residuals",
     ylim=c(-4.5,4.5))
plot(model4_white$fitted.values,ext.student.res,
     main="Externally Studentized Residuals",
     ylim=c(-4.5,4.5))

```

```{r}
##predicted survival rate for test data based on training data
preds<-predict(model4_white, newdata=test_white, type="response")
##transform the input data into a format that is suited for the
##performance() function
rates<-prediction(preds, test_white$quality_cat, label.ordering = c("low", "high"))
##store the true positive and false positive rates
roc_result<-performance(rates,measure="tpr", x.measure="fpr")


##plot ROC curve and overlay the diagonal line for random guessing
plot(roc_result, main="ROC Curve for White Wine Quality Prediction")
lines(x = c(0,1), y = c(0,1), col="red")
```


```{r}
table(test_white$quality_cat, preds>0.5)
```






